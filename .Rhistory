se <- sd/sqrt(nrow(leaders))
# Step 3, find the confidence level quantile
# input the confidence level, mean, and sd of the distribution, it will give you a number
quantile.value <- qnorm(0.95, 0, 1)
# Step 4, build your CI ~ don't forget to use standard error not standard deviation
lwr <- xbar - (quantile.value*se)
upr <- xbar + (quantile.value*se)
ci <- c(lwr, upr)
ci
View(leaders)
knitr::opts_chunk$set(echo = TRUE)
# p_load is a function in the pacman package which installs a package if haven't already and
# then calls it using the library() function
pacman::p_load(ggplot2, dplyr, wesanderson, ggfortify)
leaders <- read.csv("leaders.csv")
# Drop the first 14 empty columns
leaders <- leaders[(1:250), (15:28)]
leaders$success <- ifelse(leaders$result == "dies between a day and a week"|
leaders$result =="dies between a week and a month"|
leaders$result == "dies within a day after the attack"|
leaders$result == "dies, timing unknown", 1, 0)
leaders <- mutate(leaders, diff = polityafter - politybefore)
# The standard normal has a mean of 0 and a SD of 1
# The theoretical PDF is
ggdistribution(dnorm, seq(-5, 5, 0.1), mean = 0, sd = 1) +
geom_vline(xintercept = (qnorm(0.95, 0, 1)), colour = "blue") +
geom_vline(xintercept = (qnorm(0.05, 0, 1)), colour = "dark blue") +
labs(title = "Plot of the Theoretical PDF of the Normal Distribution",
subtitle = "Mean of 0 and Standard Deviation of 1") +
xlab("Value") +
ylab("Probability of Value Occuring") +
theme_light() +
annotate("text", x = - 1.7, y = 0.2, label = "0.05 \nQuantile") +
annotate("text", x = 1.7, y = 0.2, label = "0.95 \nQuantile") +
annotate("text", x = - 3.3, y = 0.07,
label = "5% of Observations \nlie under the curve") +
annotate("text", x = 3.3, y = 0.07,
label = "5% of Observations \nlie under the curve")
# The Theretical CDF is
ggdistribution(pnorm, seq(-5, 5, 0.1), mean = 0, sd = 1) +
labs(title = "CDF of the Normal Distribution",
subtitle = "Mean of 0 and Standard Deviation of 11") +
xlab("Value of Normal Distribution") +
ylab("Probability of Value Less Than or Equal to Occuring") +
theme_light() + geom_vline(xintercept = 0, colour = "dark blue") +
annotate("text", x = 2.75, y = 0.7,
label = "50% of Observations \n are greater than 0") +
annotate("text", x = - 2.75, y = 0.3,
label = "50% of Observations \n are less than 0")
# Step 1, find x bar (empircal mean)
xbar <- mean(leaders$polityafter, na.rm = TRUE)
# Step 2, find the standard deviation & standard error
sd <- sd(leaders$polityafter)
se <- sd/sqrt(nrow(leaders))
# Step 3, find the confidence level quantile
# input the confidence level, mean, and sd of the distribution, it will give you a number
quantile.value <- qnorm(0.95, 0, 1)
# Step 4, build your CI ~ don't forget to use standard error not standard deviation
lwr <- xbar - (quantile.value*se)
upr <- xbar + (quantile.value*se)
ci <- c(lwr, upr)
ci
# Step 1, find the z score
# The z score is a standardized value which can be mapped onto the normal distribution
z.score <- (xbar - 0)/sd
# Step 2, get the p-value for the z score
# The p-value returns the area under the curve to the left (lower tail) of the z score
# Here I changed the defualt to return the upper tail
p.value <- pnorm(z.score, mean = 0, sd = 1, lower.tail = F)
# Side note, here's a visual of what we just did
ggdistribution(dnorm, seq(-20, 20, 0.01), mean = xbar, sd = sd) +
geom_vline(xintercept = (qnorm(0.95, xbar, sd)), colour = "blue") +
geom_vline(xintercept = (p.value), colour = "dark blue") +
labs(title = "Plot of the PDF of the Normal Distribution",
subtitle = "Mean of -1.65 and Standard Deviation of 6.5") +
xlab("Value") + ylab("Probability of Value Occuring") +
theme_light() +
annotate("text", x = p.value, y = 0.075, label = "P Value") +
annotate("text", x = 9, y = 0.05, label = "0.95 \nQuantile")
# Step 3, reject or do not reject the null hypothesis
# Here we want to find out whether the area to the left is less than or greater than
# 0.05 percent; if the p value is greater than 0.05 then we are less than
# 95% confident in our estimate
ifelse(p.value > 0.05, "Do not reject the null", "Reject the Null")
treat <- subset(leaders, success == 1)
control <- subset(leaders, success == 0)
treat.mean <- mean(treat$diff, na.rm = T)
control.mean <- mean(control$diff, na.rm = T)
treat.sd <- sd(treat$diff, na.rm = T)
control.sd <- sd(control$diff, na.rm = T)
treat.se <- treat.sd/sqrt(nrow(treat))
control.se <- control.sd/sqrt(nrow(control))
# Joint standard error
joint.se <- sqrt((var(treat$diff)/nrow(treat)) +
(var(control$diff)/nrow(control)))
# Difference in means
dim <- treat.mean - control.mean
# Find the quantile
q <- qnorm(0.95, 0, 1)
# Make the CI
lower <- dim - (joint.se*q)
upper <- dim + (joint.se*q)
ci <- c(lower, upper)
ci
# Get the z score
z.score.joint <- (dim - 0)/joint.se
# Find the p value
p.value.joint <- pnorm(z.score.joint, 0, 1, lower.tail = F)
# Check what's going on
ifelse(p.value.joint > 0.05, "Do not reject the null", "Reject the null")
# Step 1, find the z score
# The z score is a standardized value which can be mapped onto the normal distribution
z.score <- (xbar - 0)/sd
# Step 2, get the p-value for the z score
# The p-value returns the area under the curve to the left (lower tail) of the z score
# Here I changed the defualt to return the upper tail
p.value <- pnorm(z.score, mean = 0, sd = 1, lower.tail = F)
p.value <- 1- p.value
# Side note, here's a visual of what we just did
ggdistribution(dnorm, seq(-20, 20, 0.01), mean = xbar, sd = sd) +
geom_vline(xintercept = (qnorm(0.95, xbar, sd)), colour = "blue") +
geom_vline(xintercept = (p.value), colour = "dark blue") +
labs(title = "Plot of the PDF of the Normal Distribution",
subtitle = "Mean of -1.65 and Standard Deviation of 6.5") +
xlab("Value") + ylab("Probability of Value Occuring") +
theme_light() +
annotate("text", x = p.value, y = 0.075, label = "P Value") +
annotate("text", x = 9, y = 0.05, label = "0.95 \nQuantile")
# Step 3, reject or do not reject the null hypothesis
# Here we want to find out whether the area to the left is less than or greater than
# 0.05 percent; if the p value is greater than 0.05 then we are less than
# 95% confident in our estimate
ifelse(p.value > 0.05, "Do not reject the null", "Reject the Null")
# Step 1, find the z score
# The z score is a standardized value which can be mapped onto the normal distribution
z.score <- (xbar - 0)/sd
# Step 2, get the p-value for the z score
# The p-value returns the area under the curve to the left (lower tail) of the z score
# Here I changed the defualt to return the upper tail
p.value <- pnorm(z.score, mean = xbar, sd = sd, lower.tail = F)
p.value <- p.value
# Side note, here's a visual of what we just did
ggdistribution(dnorm, seq(-20, 20, 0.01), mean = xbar, sd = sd) +
geom_vline(xintercept = (qnorm(0.95, xbar, sd)), colour = "blue") +
geom_vline(xintercept = (p.value), colour = "dark blue") +
labs(title = "Plot of the PDF of the Normal Distribution",
subtitle = "Mean of -1.65 and Standard Deviation of 6.5") +
xlab("Value") + ylab("Probability of Value Occuring") +
theme_light() +
annotate("text", x = p.value, y = 0.075, label = "P Value") +
annotate("text", x = 9, y = 0.05, label = "0.95 \nQuantile")
# Step 3, reject or do not reject the null hypothesis
# Here we want to find out whether the area to the left is less than or greater than
# 0.05 percent; if the p value is greater than 0.05 then we are less than
# 95% confident in our estimate
ifelse(p.value > 0.05, "Do not reject the null", "Reject the Null")
# Step 1, find x bar (empircal mean)
xbar <- mean(leaders$polityafter, na.rm = TRUE)
# Step 2, find the standard deviation & standard error
sd <- sd(leaders$polityafter)
se <- sd/sqrt(nrow(leaders))
# Step 3, find the confidence level quantile
# input the confidence level, mean, and sd of the distribution, it will give you a number
quantile.value <- qnorm(0.05, 0, 1)
# Step 4, build your CI ~ don't forget to use standard error not standard deviation
lwr <- xbar - (quantile.value*se)
upr <- xbar + (quantile.value*se)
ci <- c(lwr, upr)
ci
# Step 1, find x bar (empircal mean)
xbar <- mean(leaders$polityafter, na.rm = TRUE)
# Step 2, find the standard deviation & standard error
sd <- sd(leaders$polityafter)
se <- sd/sqrt(nrow(leaders))
# Step 3, find the confidence level quantile
# input the confidence level, mean, and sd of the distribution, it will give you a number
quantile.value <- qnorm(0.95, 0, 1)
# Step 4, build your CI ~ don't forget to use standard error not standard deviation
lwr <- xbar - (quantile.value*se)
upr <- xbar + (quantile.value*se)
ci <- c(lwr, upr)
ci
knitr::opts_chunk$set(echo = TRUE)
# p_load is a function in the pacman package which installs a package if haven't already and
# then calls it using the library() function
pacman::p_load(ggplot2, dplyr, wesanderson, ggfortify)
leaders <- read.csv("leaders.csv")
# Drop the first 14 empty columns
leaders <- leaders[(1:250), (15:28)]
leaders$success <- ifelse(leaders$result == "dies between a day and a week"|
leaders$result =="dies between a week and a month"|
leaders$result == "dies within a day after the attack"|
leaders$result == "dies, timing unknown", 1, 0)
leaders <- mutate(leaders, diff = polityafter - politybefore)
# The standard normal has a mean of 0 and a SD of 1
# The theoretical PDF is
ggdistribution(dnorm, seq(-5, 5, 0.1), mean = 0, sd = 1) +
geom_vline(xintercept = (qnorm(0.95, 0, 1)), colour = "blue") +
geom_vline(xintercept = (qnorm(0.05, 0, 1)), colour = "dark blue") +
labs(title = "Plot of the Theoretical PDF of the Normal Distribution",
subtitle = "Mean of 0 and Standard Deviation of 1") +
xlab("Value") +
ylab("Probability of Value Occuring") +
theme_light() +
annotate("text", x = - 1.7, y = 0.2, label = "0.05 \nQuantile") +
annotate("text", x = 1.7, y = 0.2, label = "0.95 \nQuantile") +
annotate("text", x = - 3.3, y = 0.07,
label = "5% of Observations \nlie under the curve") +
annotate("text", x = 3.3, y = 0.07,
label = "5% of Observations \nlie under the curve")
# The standard normal has a mean of 0 and a SD of 1
# The theoretical PDF is
ggdistribution(dnorm, seq(-5, 5, 0.1), mean = 0, sd = 1) +
geom_vline(xintercept = (qnorm(0.95, 0, 1)), colour = "blue") +
geom_vline(xintercept = (qnorm(0.05, 0, 1)), colour = "green") +
labs(title = "Plot of the Theoretical PDF of the Normal Distribution",
subtitle = "Mean of 0 and Standard Deviation of 1") +
xlab("Value") +
ylab("Probability of Value Occuring") +
theme_light() +
annotate("text", x = - 1.7, y = 0.2, label = "0.05 \nQuantile") +
annotate("text", x = 1.7, y = 0.2, label = "0.95 \nQuantile") +
annotate("text", x = - 3.3, y = 0.07,
label = "5% of Observations \nlie under the curve") +
annotate("text", x = 3.3, y = 0.07,
label = "5% of Observations \nlie under the curve")
# The Theretical CDF is
ggdistribution(pnorm, seq(-5, 5, 0.1), mean = 0, sd = 1) +
labs(title = "CDF of the Normal Distribution",
subtitle = "Mean of 0 and Standard Deviation of 11") +
xlab("Value of Normal Distribution") +
ylab("Probability of Value Less Than or Equal to Occuring") +
theme_light() + geom_vline(xintercept = 0, colour = "dark blue") +
annotate("text", x = 2.75, y = 0.7,
label = "50% of Observations \n are greater than 0") +
annotate("text", x = - 2.75, y = 0.3,
label = "50% of Observations \n are less than 0")
# Step 1, find x bar (empircal mean)
xbar <- mean(leaders$polityafter, na.rm = TRUE)
# Step 2, find the standard deviation & standard error
sd <- sd(leaders$polityafter)
se <- sd/sqrt(nrow(leaders))
# Step 3, find the confidence level quantile
# input the confidence level, mean, and sd of the distribution, it will give you a number
quantile.value <- qnorm(0.95, 0, 1)
# Step 4, build your CI ~ don't forget to use standard error not standard deviation
lwr <- xbar - (quantile.value*se)
upr <- xbar + (quantile.value*se)
ci <- c(lwr, upr)
ci
# Step 1, find the z score
# The z score is a standardized value which can be mapped onto the normal distribution
z.score <- (xbar - 0)/sd
# Step 2, get the p-value for the z score
# The p-value returns the area under the curve to the left (lower tail) of the z score
# Here I changed the defualt to return the upper tail
p.value <- pnorm(z.score, mean = 1, sd = 0, lower.tail = F)
# Side note, here's a visual of what we just did
ggdistribution(dnorm, seq(-20, 20, 0.01), mean = xbar, sd = sd) +
geom_vline(xintercept = (qnorm(0.95, xbar, sd)), colour = "blue") +
geom_vline(xintercept = (p.value), colour = "dark blue") +
labs(title = "Plot of the PDF of the Normal Distribution",
subtitle = "Mean of -1.65 and Standard Deviation of 6.5") +
xlab("Value") + ylab("Probability of Value Occuring") +
theme_light() +
annotate("text", x = p.value, y = 0.075, label = "P Value") +
annotate("text", x = 9, y = 0.05, label = "0.95 \nQuantile")
# Step 3, reject or do not reject the null hypothesis
# Here we want to find out whether the area to the left is less than or greater than
# 0.05 percent; if the p value is greater than 0.05 then we are less than
# 95% confident in our estimate
ifelse(p.value > 0.05, "Do not reject the null", "Reject the Null")
# Step 1, find the z score
# The z score is a standardized value which can be mapped onto the normal distribution
z.score <- (xbar - 0)/sd
# Step 2, get the p-value for the z score
# The p-value returns the area under the curve to the left (lower tail) of the z score
# Here I changed the defualt to return the upper tail
p.value <- pnorm(z.score, mean = 1, sd = 0, lower.tail = F)
# Side note, here's a visual of what we just did
ggdistribution(dnorm, seq(-20, 20, 0.01), mean = xbar, sd = sd) +
geom_vline(xintercept = (qnorm(0.95, xbar, sd)), colour = "blue") +
geom_vline(xintercept = (p.value), colour = "green") +
labs(title = "Plot of the PDF of the Normal Distribution",
subtitle = "Mean of -1.65 and Standard Deviation of 6.5") +
xlab("Value") + ylab("Probability of Value Occuring") +
theme_light() +
annotate("text", x = p.value, y = 0.075, label = "P Value") +
annotate("text", x = 9, y = 0.05, label = "0.95 \nQuantile")
# Step 3, reject or do not reject the null hypothesis
# Here we want to find out whether the area to the left is less than or greater than
# 0.05 percent; if the p value is greater than 0.05 then we are less than
# 95% confident in our estimate
ifelse(p.value > 0.05, "Do not reject the null", "Reject the Null")
treat <- subset(leaders, success == 1)
control <- subset(leaders, success == 0)
treat.mean <- mean(treat$diff, na.rm = T)
control.mean <- mean(control$diff, na.rm = T)
treat.sd <- sd(treat$diff, na.rm = T)
control.sd <- sd(control$diff, na.rm = T)
treat.se <- treat.sd/sqrt(nrow(treat))
control.se <- control.sd/sqrt(nrow(control))
# Joint standard error
joint.se <- sqrt((var(treat$diff)/nrow(treat)) +
(var(control$diff)/nrow(control)))
# Difference in means
dim <- treat.mean - control.mean
# Find the quantile
q <- qnorm(0.95, 0, 1)
# Make the CI
lower <- dim - (joint.se*q)
upper <- dim + (joint.se*q)
ci <- c(lower, upper)
ci
# Joint standard error
joint.se <- sqrt((var(treat$diff)/nrow(treat)) +
(var(control$diff)/nrow(control)))
# Difference in means
dim <- treat.mean - control.mean
# Find the quantile; 2.5% in each tail
q <- qnorm(0.975, 0, 1)
# Make the CI
lower <- dim - (joint.se*q)
upper <- dim + (joint.se*q)
ci <- c(lower, upper)
ci
# Get the z score
z.score.joint <- (dim - 0)/joint.se
# Find the p value
p.value.joint <- pnorm(z.score.joint, 0, 1, lower.tail = F)
# Check what's going on
ifelse(p.value.joint > 0.05, "Do not reject the null", "Reject the null")
View(leaders)
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(ggplot2, tidyverse, wesanderson, texreg)
leaders <- read.csv("leaders.csv")
leaders$success <- ifelse(leaders$result == "dies between a day and a week"|
leaders$result =="dies between a week and a month"|
leaders$result == "dies within a day after the attack"|
leaders$result == "dies, timing unknown", 1, 0)
leaders <- mutate(leaders, diff = polityafter - politybefore)
# Use the lm function to do a regression
# Place one variable on the left of the ~, it is your outcome or dependent variables
# The variables to the right are the independent variables; they predict the outcome variable
model1 <- lm(diff ~ success, data = leaders)
model2 <- lm(diff ~ success + age, data = leaders)
model3 <- lm(diff ~ success * age + region + decade, data = leaders)
# Two different ways to visualize your regression
# screenreg() is a function from the texreg package; it is useful for showing multiple models that use
# the same outcome variable
screenreg(list(model1, model2, model3), custom.model.names = c("Basic Model", "Model 2", "Full Model"))
# summary calls all the information
# Estimate is the effect of the independent variable on the dependent variable
# Standard deviation is the distance from the estimate approcximately 50% of observations are within
summary(model2)
# We add three new columsn to the leaders dataset, for the estimate, and the lower and upper bounds
# of the confidence interval (based on the standard deviation)
# we use the predict function, calling the model, then the dataset to draw values from
# set interval = confidence; the default is the 95% confidence interval
leaders[, c("fit", "lwr", "upr")] <- predict(model3, leaders, interval = "confidence")
# The first layer plots the actual values
ggplot(leaders, aes(x = year, y = diff, color = as.factor(success))) + geom_point() +
labs(title = "Change in Polity Score in Countries with Leader Assassination Attempt, by Year",
x = "Year", y = "Post - Pre Polity Score", color = "Success of \n Attmept",
subtitle = "Actual Values are Circles, Predicted Values are Triangles") +
# here I add another layer of geom_point, I set inherit.aes = FALSE so that it does not use the same
# aesthetics as it did in the first layer, I give the points a different shape to see the difference
# between our predicted and actual data
geom_point(inherit.aes = FALSE, data = leaders,
mapping = aes(x = year, y = fit, color = as.factor(success)), shape = 17, size = 2.5)
# Success is either a zero or a 1
success_cats <- c(0, 1)
# Make a vector with all possible ages from the minimum to the maximum
age_range <- seq(from = min(leaders$age), to = max(leaders$age), by = 1)
# Make a vector with a list of regions
regions_all <- unique(leaders$region)
# Finally a vector with al the decades
decades <- seq(from = min(leaders$decade), to = max(leaders$decade), by = 10)
# Now pass these to the expand grid function. Everything the left of an = will be the new column
# name so make sure that the names are the same as in the original datafram, otherwise predict
# won't work
fake_leaders <- expand_grid(success = success_cats,
age = age_range,
region = regions_all,
decade = decades)
View(fake_leaders)
fake_leaders[, c("upr", "lwr", "fit")] <- predict(object = model3,
data = fake_leaders,
type = "confidence")
View(model3)
fake_leaders[, c("upr", "lwr", "fit")] <- predict(object = model3,
data = fake_leaders,
interval = "confidence")
fake_leaders[, c("upr", "lwr", "fit")] <- predict(model3,
fake_leaders,
interval = "confidence")
ggplot(data = fake_leaders, aes(x = age, y = fit, fill = success)) +
geom_point() +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
legend = "Success of/nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt")
ggplot(data = fake_leaders, aes(x = age, y = fit,
shape = as.factor(success), fill = region)) +
geom_point() +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
legend = "Success of/nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt")
ggplot(data = fake_leaders, aes(x = age, y = fit, fill = as.factor(success))) +
geom_point() +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
legend = "Success of/nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt")
ggplot(data = fake_leaders, aes(x = age, y = fit, fill = as.factor(success))) +
geom_point() +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
fill = "Success of/nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt") +
scale_fill_discrete(labels = c("Unsuccessful", "Successful"),
values = c("red3", "olivedrab3"))
ggplot(data = fake_leaders, aes(x = age, y = fit, fill = as.factor(success))) +
geom_point() +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
fill = "Success of/nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt") +
scale_fill_manual(labels = c("Unsuccessful", "Successful"),
values = c("red3", "olivedrab3"))
ggplot(data = fake_leaders, aes(x = age, y = fit, fill = as.factor(success))) +
geom_point() +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
fill = "Success of\nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt") +
scale_fill_manual(labels = c("Unsuccessful", "Successful"),
values = c("red3", "olivedrab3"))
ggplot(data = fake_leaders, aes(x = age, y = fit, fill = as.factor(success))) +
geom_point() +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
fill = "Success of\nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt") +
scale_fill_manual(labels = c("Unsuccessful", "Successful"),
values = c("red3", "yellowgreen"))
ggplot(data = fake_leaders, aes(x = age, y = fit, fill = as.factor(success))) +
geom_point() +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
fill = "Success of\nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt") +
scale_fill_manual(labels = c("Unsuccessful", "Successful"),
values = c("red", "yellowgreen"))
ggplot(data = fake_leaders) +
geom_point(aes(x = age, y = fit, colour = as.factor(success))) +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
fill = "Success of\nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt") +
scale_colour_manual(labels = c("Unsuccessful", "Successful"),
values = c("red3", "green2"))
ggplot(data = fake_leaders) +
geom_point(aes(x = age, y = fit, colour = as.factor(success)),
alpha = 0.4, size = 7) +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
colour = "Success of\nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt") +
scale_colour_manual(labels = c("Unsuccessful", "Successful"),
values = c("red3", "greenyellow"))
ggplot(data = fake_leaders) +
geom_point(aes(x = age, y = fit, colour = as.factor(success)),
alpha = 0.4, size = 2) +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
colour = "Success of\nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt") +
scale_colour_manual(labels = c("Unsuccessful", "Successful"),
values = c("red3", "greenyellow"))
ggplot(data = fake_leaders) +
geom_point(aes(x = age, y = fit, colour = as.factor(success)),
alpha = 0.4, size = 0.2) +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
colour = "Success of\nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt") +
scale_colour_manual(labels = c("Unsuccessful", "Successful"),
values = c("red3", "greenyellow"))
ggplot(data = fake_leaders) +
geom_point(aes(x = age, y = fit, colour = as.factor(success)),
alpha = 0.4, size = 0.5) +
labs(x = "Leader Age",
y = "Predicted Difference in Polity Score After an Assassination",
colour = "Success of\nAttempt",
title = "Predicive Plot of Change in Polity Scores After an Assassination Attempt",
subtitle = "Coloured by Success of Attempt") +
scale_colour_manual(labels = c("Unsuccessful", "Successful"),
values = c("red3", "greenyellow"))
